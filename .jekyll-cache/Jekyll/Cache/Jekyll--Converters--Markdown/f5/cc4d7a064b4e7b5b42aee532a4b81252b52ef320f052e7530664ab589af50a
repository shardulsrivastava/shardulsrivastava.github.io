I"T/<p>With Cloud, distributed architectures have grown even more complex and with complexity comes the uncertainty in how the system could fail.</p>

<p>Chaos Engineering aims to test system resiliency by injecting faults to identify weaknesses before they cause massive outages such as improper fallback settings for a service, cascading failures due to a single point of failure, or retry storms due to misconfigured timeouts.</p>

<h4 id="history">History</h4>

<p>Chaos Engineering started at Netflix back in 2010 when Netflix moved from on-prem servers to AWS infrastructure to test the resiliency of their infrastructure.</p>

<p>In 2012, Netflix open-sourced <a href="https://github.com/Netflix/chaosmonkey">ChaosMonkey</a> under Apache 2.0 license that randomly terminates instances to ensure that services are resilient to instance failures.</p>

<h4 id="cloud-native-chaos-engineering-in-cncf-landscape">Cloud Native Chaos Engineering in CNCF Landscape</h4>

<p>CNCF focuses on Cloud Native Chaos Engineering defined as engineering practices focused on (and built on) Kubernetes environments, applications, microservices, and infrastructure.</p>

<p>Cloud Native Chaos Engineering has 4 core principles:</p>
<ol>
  <li>Open source</li>
  <li>CRDs for Chaos Management</li>
  <li>Extensible and pluggable</li>
  <li>Broad Community adoption</li>
</ol>

<p>CNCF has two sandbox projects for Cloud Native Chaos Engineering</p>

<ol>
  <li><a href="https://github.com/chaos-mesh/chaos-mesh">ChaosMesh</a></li>
  <li><a href="https://github.com/litmuschaos/litmus">Litmus Chaos</a></li>
</ol>

<p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gmb5uh3kd7q6izwjsf3i.png" alt="cncf-chaos-engineering" /></p>

<h4 id="chaos-mesh">Chaos Mesh</h4>

<p>Chaos Mesh is a cloud-native Chaos Engineering platform that orchestrates chaos on Kubernetes environments. It is based on <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/">Kubernetes Operator pattern</a> and provides a Chaos Operator to inject into the applications and Kubernetes infrastructure in a manageable way.</p>

<p>Chaos Operator uses Custom Resource Defition(CRD) to define chaos objects. It provides a variety of these CRDs for fault injection such as :</p>

<ol>
  <li><a href="https://chaos-mesh.org/docs/simulate-pod-chaos-on-kubernetes/">PodChaos</a></li>
  <li><a href="https://chaos-mesh.org/docs/simulate-network-chaos-on-kubernetes">NetworkChaos</a></li>
  <li><a href="https://chaos-mesh.org/docs/simulate-dns-chaos-on-kubernetes">DNSChaos</a></li>
  <li><a href="https://chaos-mesh.org/docs/simulate-http-chaos-on-kubernetes">HTTPChaos</a></li>
  <li><a href="https://chaos-mesh.org/docs/simulate-heavy-stress-on-kubernetes">StressChaos</a></li>
  <li><a href="https://chaos-mesh.org/docs/simulate-io-chaos-on-kubernetes">IOChaos</a></li>
  <li><a href="https://chaos-mesh.org/docs/simulate-time-chaos-on-kubernetes">TimeChaos</a></li>
  <li><a href="https://chaos-mesh.org/docs/simulate-kernel-chaos-on-kubernetes">KernelChaos</a></li>
  <li><a href="https://chaos-mesh.org/docs/simulate-aws-chaos">AWSChaos</a></li>
  <li><a href="https://chaos-mesh.org/docs/simulate-gcp-chaos">GCPChaos</a></li>
  <li><a href="https://chaos-mesh.org/docs/simulate-jvm-application-chaos">JVMChaos</a></li>
</ol>

<h4 id="chaos-mesh-installation">Chaos Mesh Installation</h4>

<p>Chaos Mesh can be installed quickly using <a href="https://chaos-mesh.org/docs/quick-start#quick-installation">installation script</a>. However, it’s recommended to use Helm 3 chart in production environments.</p>

<p>To install Chaos Mesh using Helm :</p>

<ol>
  <li>
    <p>Add the Chaos Mesh repository to the Helm repository.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>helm repo add chaos-mesh https://charts.chaos-mesh.org
</code></pre></div>    </div>
  </li>
  <li>
    <p>It’s recommended to install ChaosMesh in a separate namespace, so you can either create a namespace <code class="language-html highlighter-rouge">chaos-testing</code> manually or let Helm create it automatically, if it doesn’t exist :</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>helm upgrade <span class="se">\</span>
     <span class="nt">--install</span> <span class="se">\</span>
     chaos-mesh <span class="se">\</span>
     chaos-mesh/chaos-mesh <span class="se">\</span>
     <span class="nt">-n</span> chaos-testing <span class="se">\</span>
     <span class="nt">--create-namespace</span> <span class="se">\</span>
     <span class="nt">--version</span> v2.0.0 <span class="se">\</span>
     <span class="nt">--wait</span>
</code></pre></div>    </div>

    <p>Note: If you’re using GKE or EKS with <code class="language-html highlighter-rouge">containerd</code>, then use</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>helm upgrade <span class="se">\</span>
     <span class="nt">--install</span> <span class="se">\</span>
     chaos-mesh <span class="se">\</span>
     chaos-mesh/chaos-mesh <span class="se">\</span>
     <span class="nt">-n</span> chaos-testing <span class="se">\</span>
     <span class="nt">--create-namespace</span> <span class="se">\</span>
     <span class="nt">--set</span> chaosDaemon.runtime<span class="o">=</span>containerd <span class="se">\</span>
     <span class="nt">--set</span> chaosDaemon.socketPath<span class="o">=</span>/run/containerd/containerd.sock <span class="se">\</span>
     <span class="nt">--version</span> v2.0.0 <span class="se">\</span>
     <span class="nt">--wait</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Verify if pods are running :</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods <span class="nt">-n</span> chaos-testing
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="run-first-chaos-mesh-experiment">Run First Chaos Mesh Experiment</h4>

<p>Chaos Experiment describes what type of fault is injected and how.</p>

<ol>
  <li>
    <p>Setup an Nginx pod and expose it on port 80.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl run nginx <span class="nt">--image</span><span class="o">=</span>nginx <span class="nt">--labels</span><span class="o">=</span><span class="s2">"app=nginx"</span> <span class="nt">--port</span><span class="o">=</span>80
</code></pre></div>    </div>
  </li>
  <li>
    <p>Get the IP of the nginx pod</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods nginx <span class="nt">-ojsonpath</span><span class="o">=</span><span class="s2">"{.status.podIP}"</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Open another terminal and setup a test pod to test the connectivity to nginx pod :</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl run <span class="nt">-it</span> test-connection <span class="nt">--image</span><span class="o">=</span>radial/busyboxplus:curl <span class="nt">--</span> sh
ping &lt;IP of the Nginx Pod&gt; <span class="nt">-c</span> 2
</code></pre></div>    </div>

    <p>this should show you the time it takes to ping the IP :</p>

    <p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/tpjo9rn4tw0gy2rb6mao.png" alt="nginx-pod-connectivity" /></p>
  </li>
  <li>
    <p>Create your first Chaos Experiment by running :</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> - <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
apiVersion: chaos-mesh.org/v1alpha1
kind: NetworkChaos
metadata:
  name: nginx-network-delay
spec:
  action: delay
  mode: one
  selector:
    namespaces:
      - default
    labelSelectors:
      'app': 'nginx'
  delay:
    latency: '1s'
  duration: '60s'
</span><span class="no">EOF
</span></code></pre></div>    </div>

    <p>this will create a CRD of type <code class="language-html highlighter-rouge">NetworkChaos</code> that will introduce a latency of <code class="language-html highlighter-rouge">1 second</code> in the network of pods with labels <code class="language-html highlighter-rouge">app:nginx</code> i.e nginx pod for the next <code class="language-html highlighter-rouge">60 seconds</code>.</p>
  </li>
  <li>
    <p>Test the response of ping to the nginx pod now to see the delay of <code class="language-html highlighter-rouge">1 second</code>.</p>

    <p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/z0m58z0ya82bmf6hiwix.png" alt="nginx-pod-connectivity-with-delay" /></p>
  </li>
</ol>

<h4 id="run-httpchaos-experiment">Run HTTPChaos Experiment</h4>

<p><code class="language-html highlighter-rouge">HTTPChaos</code> allows you to inject faults in the request and response of an HTTP server. It supports <code class="language-html highlighter-rouge">abort</code>,<code class="language-html highlighter-rouge">delay</code>,<code class="language-html highlighter-rouge">replace</code>,<code class="language-html highlighter-rouge">patch</code> fault types.</p>

<p><code class="language-html highlighter-rouge">Note: Before proceeding, delete the NetworkChaos experiment created earlier.</code></p>

<ol>
  <li>
    <p>Check the response time of nginx pod :</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl <span class="nb">exec</span> <span class="nt">-it</span> test-connection <span class="nt">--</span> sh
<span class="nb">time </span>curl &lt;IP of the Nginx Pod&gt;
</code></pre></div>    </div>

    <p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/tspvf7p8ynhxh5gdnsfj.png" alt="nginx-pod-httpchaos" /></p>
  </li>
  <li>
    <p>Create <code class="language-html highlighter-rouge">HTTPSChaos</code> experiment by running:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> - <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
apiVersion: chaos-mesh.org/v1alpha1
kind: HTTPChaos
metadata:
  name: nginx-http-delay
spec:
  mode: all
  selector:
    labelSelectors:
      app: nginx
  target: Request
  port: 80
  delay: 1s
  method: GET
  path: /
  duration: 5m
</span><span class="no"> EOF
</span></code></pre></div>    </div>

    <p>this will create a CRD of type <code class="language-html highlighter-rouge">HTTPChaos</code> that will introduce a latency of <code class="language-html highlighter-rouge">1 seconds</code> to the requests sent to the pods with labels <code class="language-html highlighter-rouge">app:nginx</code> i.e nginx pod on port 80 for the next <code class="language-html highlighter-rouge">5 mins</code>.</p>

    <p>Note: If you get an error like <code class="language-html highlighter-rouge">admission webhook "vauth.kb.io" denied the request</code>, as of version 2.0 there is an open issue <a href="https://github.com/chaos-mesh/chaos-mesh/issues/2187">2187</a> and a temporary fix is to delete the validating webhook.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl delete validatingwebhookconfigurations.admissionregistration.k8s.io validate-auth
</code></pre></div>    </div>
  </li>
  <li>
    <p>Test the response time of nginx pod :</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">time </span>curl &lt;IP of the Nginx Pod&gt;
</code></pre></div>    </div>

    <p>you will see the additional <code class="language-html highlighter-rouge">1 second</code> latency in the response.</p>

    <p><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/hscss8vmlksy2sv9zp3e.png" alt="nginx-pod-httpchaos-delay" /></p>
  </li>
</ol>
:ET